---
title: Integrating Initia Minitswap
---

## Interacting with Minitswap

### Provide

To provide INIT liquidity to Minitswap, you would need to use the `provide` function. 

By adding liquidity, you will help facilitate swaps between L1 and L2 INIT tokens. In return, you'll earn swap fees and arbitrage fees generated from the transactions that occur on Minitswap.

**Move Function Interface:**

```ts
public entry fun provide(
  account: &signer,
  amount: u64,
  min_return_amount: Option<u64>,
)
```

- `amount`: The amount of L1 INIT to provide.
- `min_return_amount`: Ensures the transaction fails if the return amount is less than specified.

**Example Usage:**

<Tabs>
    <Tab title="CLI">
    ```bash
    initiad tx move execute 0x1 minitswap provide \ 
        --args "u64:100 option<u64>:100" \
        --from [key-name] \
        --gas auto --gas-adjustment 1.5 --gas-prices 0.15uinit \
        --node [rpc-url]:[rpc-port] --chain-id [chain-id]
    ```
    </Tab>
    <Tab title="InitiaJS">
    ```ts
    import {
        bcs,
        LCDClient,
        MnemonicKey,
        MsgExecute,
        Wallet,
    } from '@initia/initia.js';

    async function main() {
        const lcd = new LCDClient('[rest-url]', {
            gasPrices: '0.15uinit',
            gasAdjustment: '1.5',
        });

        const key = new MnemonicKey({
            mnemonic: 'beauty sniff protect ...',
        });
        const wallet = new Wallet(lcd, key);

        const msgs = [
            new MsgExecute(
            key.accAddress,
            '0x1',
            'minitswap',
            'provide',
            [],
            [
                bcs.u64().serialize(100).toBase64(), // amount to provide
                bcs.option(bcs.u64()).serialize(100).toBase64(), // min return amount
            ]
            ),
        ];

        // sign tx
        const signedTx = await wallet.createAndSignTx({ msgs });
        // send(broadcast) tx
        lcd.tx.broadcastSync(signedTx).then(res => console.log(res));
        // {
        //   height: 0,
        //   txhash: '0F2B255EE75FBA407267BB57A6FF3E3349522DA6DBB31C0356DB588CC3933F37',
        //   raw_log: '[]'
        // }
    }

    main();
    ```
    </Tab>
</Tabs>

## Withdraw

When you're ready to take back the liquidity you’ve provided, you can use the `withdraw` function to retrieve your INIT tokens from Minitswap.

This allows you to freely exit your position whenever you'd like and reclaim your provided liquidity plus any fees you’ve earned along the way.

**Move Function Interface:**

```move
public entry fun withdraw(
  account: &signer,
  amount: u64,
  min_return_amount: Option<u64>,
)
```

- `amount`: Specifies the share amount to withdraw.
- `min_return_amount`: Transaction fails if the return is less than specified.

**Example Usage:**

<Tabs>
    <Tab title="CLI">
    ```bash
    initiad tx move execute 0x1 minitswap withdraw \ 
        --args "u64:100 option<u64>:100" \
        --from [key-name] \
        --gas auto --gas-adjustment 1.5 --gas-prices 0.15uinit \
        --node [rpc-url]:[rpc-port] --chain-id [chain-id]
    ```
    </Tab>
    <Tab title="InitiaJS">
    ```ts
    import {
        bcs,
        LCDClient,
        MnemonicKey,
        MsgExecute,
        Wallet,
    } from '@initia/initia.js';

    async function main() {
        const lcd = new LCDClient('[rest-url]', {
            gasPrices: '0.15uinit',
            gasAdjustment: '1.5',
        });

        const key = new MnemonicKey({
            mnemonic: 'beauty sniff protect ...',
        });
        const wallet = new Wallet(lcd, key);

        const msgs = [
            new MsgExecute(
            key.accAddress,
            '0x1',
            'minitswap',
            'withdraw',
            [],
            [
                bcs.u64().serialize(100).toBase64(), // amount to withdraw
                bcs.option(bcs.u64()).serialize(100).toBase64(), // min return amount
            ]
            ),
        ];

        // sign tx
        const signedTx = await wallet.createAndSignTx({ msgs });
        // send(broadcast) tx
        lcd.tx.broadcastSync(signedTx).then(res => console.log(res));
        // {
        //   height: 0,
        //   txhash: '0F2B255EE75FBA407267BB57A6FF3E3349522DA6DBB31C0356DB588CC3933F37',
        //   raw_log: '[]'
        // }
    }

    main();
    ```
    </Tab>
</Tabs>

### Swap

The `swap` function allows you to exchange L2 INIT for L1 INIT or vice versa.

**Move Function Interface:**

```move
public entry fun swap(
    account: &signer,
    offer_asset_metadata: Object<Metadata>,
    return_asset_metadata: Object<Metadata>,
    amount: u64,
    min_return_amount: Option<u64>
)
```

- `offer_asset_metadata`: Metadata for the provided coin.
- `return_asset_metadata`: Metadata for the coin to be returned.
- `amount`: Coin amount provided.
- `min_return_amount`: Ensures the swap fails if the return is less than specified.

For more information on metadata, please refer to [obtaining metadata](/developers/developer-guides/vm-specific-tutorials/movevm/creating-move-coin#obtaining-metadata).

**Example Usage:**

<Tabs>
    <Tab title="CLI">
    ```bash
    initiad tx move execute 0x1 minitswap swap \ 
        --args "object:0x12.. object: 0x12.. u64:100 option<u64>:100" \
        --from [key-name] \
        --gas auto --gas-adjustment 1.5 --gas-prices 0.15uinit \
        --node [rpc-url]:[rpc-port] --chain-id [chain-id]
    ```
    </Tab>
    <Tab title="InitiaJS">
    ```ts
    import {
        bcs,
        LCDClient,
        MnemonicKey,
        MsgExecute,
        Wallet,
    } from '@initia/initia.js';

    async function main() {
        const lcd = new LCDClient('[rest-url]', {
            gasPrices: '0.15uinit',
            gasAdjustment: '1.5',
        });

        const key = new MnemonicKey({
            mnemonic: 'beauty sniff protect ...',
        });
        const wallet = new Wallet(lcd, key);

        const msgs = [
            new MsgExecute(
            key.accAddress,
            '0x1',
            'minitswap',
            'swap',
            [],
            [
                bcs.object().serialize('0x...').toBase64(), // metadata to offer
                bcs.object().serialize('0x...').toBase64(), // metadata to return
                bcs.u64().serialize(100).toBase64(), // offer amount
                bcs.option(bcs.u64()).serialize(100).toBase64(), // min return amount
            ]
            ),
        ];

        // sign tx
        const signedTx = await wallet.createAndSignTx({ msgs });
        // send(broadcast) tx
        lcd.tx.broadcastSync(signedTx).then(res => console.log(res));
        // {
        //   height: 0,
        //   txhash: '0F2B255EE75FBA407267BB57A6FF3E3349522DA6DBB31C0356DB588CC3933F37',
        //   raw_log: '[]'
        // }
    }

    main();
    ```
    </Tab>
</Tabs>

`swap_simulation` is a view function to estimate the return value of said swap. 

```move
#[view]
public fun swap_simulation(
    offer_metadata: Object<Metadata>,
    return_metadata: Object<Metadata>,
    offer_amount: u64,
): (u64, u64) // (return amount, fee amount)
```
- `offer_asset_metadata`: Metadata of the provided coin.
- `return_asset_metadata`: Metadata of the coin that will be returned.
- `amount`: Amount of coin provided. 

**Example Usage:**

<Tabs>
    <Tab title="curl">
    ```bash
    curl -X POST "[LCD_URI]/initia/move/v1/accounts/0x1/modules/minitswap/view_functions/swap_simulation" \
        -H "accept: application/json" \
        -H "Content-Type: application/json" \
        -d "{ \"args\": [ \"[BCS_ENCODED_OBJECT, BCS_ENCODED_OBJECT, BCS_ENCODED_OFFER_AMOUNT]\" ]}"
  
    #{
    #  "data": "[\"100\",\"100\"]",
    #  "events": [],
    #  "gas_used": "5699"
    #}        
    ```
    </Tab>
    <Tab title="CLI">
    ```bash
    initiad query move view 0x1 minitswap swap_simulation \
        --args "object:0x... object:0x... u64:123" \
        --node [rpc-url]:[rpc-port]
        
    # data: '["123", "123"]'
    # events: []
    # gas_used: "5699"
    ```
    </Tab>
    <Tab title="InitiaJS">
    ```ts
    import { LCDClient, bcs } from '@initia/initia.js';

    const lcdUri = 'https://....';
    const lcd = new LCDClient(lcdUri);

    lcd.move
        .view(
            '0x1',
            'minitswap',
            'swap_simulation',
            [],
            [
            bcs.object().serialize('0x...').toBase64(),
            bcs.object().serialize('0x...').toBase64(),
            bcs.u64().serialize(100).toBase64(),
            ]
        )
        .then(console.log);

    // { data: '["100","0"]', events: [], gas_used: '21371' }
    ```
    </Tab>
</Tabs>


### Arbitrage

Arbitrage on Minitswap helps balance L1 INIT and L2 INIT prices. 

Use the `finalize_arb` function to complete arbitrage transactions after the L2 INIT challenge period. 

Arbitrage profits are shared between the `function caller` and the `LP provider`. 

Required arguments for `finalize_arb` can be obtained from the `OPinit Executor` and Minitswap view function

**Move Function Interface:**

```move
public entry fun finalize_arb(
    account: &signer,
    arb_index: u64,
    output_index: u64,
    withdrawal_proofs: vector<String>,
    sender: address,
    sequence: u64,
    version: String,
    state_root: String,
    storage_root: String,
    latest_block_hash: String
)
```

- `arb_index`: Arbitrage index.
- `output_index`: Output index.
- `withdrawal_proofs`: Withdrawal proofs.
- `sender`: Sender of the withdrawal.
- `version`: Version of the output root.
- `state_root`: L2 state root
- `storage_root`: Withdrawal storage root
- `latest_block_hash`: L2 latest block hash

**Example Usage:**

<Tabs>
    <Tab title="CLI">
    ```bash
    initiad tx move execute 0x1 minitswap finalize_arb \ 
        --args "" \
        --from [key-name] \
        --gas auto --gas-adjustment 1.5 --gas-prices 0.15uinit \
        --node [rpc-url]:[rpc-port] --chain-id [chain-id]
    ```
    </Tab>
    <Tab title="InitiaJS">
    ```ts
    import {
        APIRequester,
        AccAddress,
        LCDClient,
        MnemonicKey,
        Msg,
        MsgExecute,
        Wallet,
        bcs,
    } from '@initia/initia.js';
    import { sha3_256 } from "@noble/hashes/sha3";
    import { bytesToHex, concatBytes, toBytes, hexToBytes } from "@noble/hashes/utils";
    import { toHex } from "@cosmjs/encoding"
    import { sha256 } from "@noble/hashes/sha256";
    
    function denomToHash(channelId: string, denom: string) {
        const fullTrace = `transfer/${channelId}/${denom}`
        const shaSum = sha256(Buffer.from(fullTrace))
        return bytesToHex(shaSum)
    }

    function ibcDenom(channelId: string, denom: string) {
        return 'ibc/' + denomToHash(channelId, denom).toUpperCase()
    }

    function be(num: bigint): number[] {
        return num ? be(num >> 8n).concat([Number(num % 256n)]) : []
    }
    
    function u64BE(num: bigint) {
        const b = be(num)
        return Buffer.from(
        Array(8 - b.length)
            .fill(0)
            .concat(b)
        )
    }
    
    function intToUint8Array(value: number): Uint8Array {
        let hex = value.toString(16);
        if (hex.length % 2 !== 0) {
        hex = '0' + hex;
        }
        return hexToBytes(hex);
    }

    function opdenom(id: bigint, l1Denom: string) {
        const sum = sha3_256
        .create()
        .update(Buffer.from([...u64BE(id), ...Buffer.from(l1Denom)]))
        .digest()
    
        return `l2/${Buffer.from(sum).toString('hex')}`
    }
    
    function coinMetadata(creator: string, symbol: string) {
        const OBJECT_FROM_SEED_ADDRESS_SCHEME = 0xfe
        const addrBytes = bcs.address().serialize(creator).toBytes()
        const seed = toBytes(symbol)
        const bytes = new Uint8Array([...concatBytes(addrBytes, seed), OBJECT_FROM_SEED_ADDRESS_SCHEME])
        const sum = sha3_256.create().update(bytes).digest()
        return toHex(sum)
    }

    const registryClient = new APIRequester('https://registry.testnet.initia.xyz/');
    const lcd = new LCDClient(`https://lcd.initiation-2.initia.xyz`, {
        chainId: 'initiation-2',
        gasPrices: '0.15uinit',
        gasAdjustment: '2.0',
    });
    const moduleAddr = '0x1';
    
    const key = new MnemonicKey({
        mnemonic: '', // Put your mnemonic here
    });
    
    const wallet = new Wallet(lcd, key);
    
    async function main() {
        listUp();
    }
    main();
    
    async function listUp() {
        const pools = await getPools();
        console.log(pools.map(p => p.virtual_pool ? p.virtual_pool.inner : null));
        const chains = await registryClient.get<Chain[]>('chains.json');
        const msgs: Msg[] = [];
        let arbCount = 0;
        for (const pool of pools) {

        if (pool.virtual_pool) {
            const channel = pool.ibc_channel;
            const bridgeId = pool.op_bridge_id;
            const ibcOpInitDenom = ibcDenom(
            channel,
            opdenom(BigInt(bridgeId), 'uinit')
            );
            const ibcOpInitMetadata = '0x' + coinMetadata('0x1', ibcOpInitDenom);
            const infos = await lcd.move.viewFunction<ArbInfo[]>(
            moduleAddr,
            'minitswap',
            'get_arb_infos',
            [],
            [
                bcs.object().serialize(ibcOpInitMetadata).toBase64(),
                bcs.option(bcs.u64()).serialize(null).toBase64(),
                bcs.u64().serialize(100).toBase64(),
            ]
            );
    
            for (const info of infos) {
            arbCount++;
            const msg = await checkCanFinalize(chains, info, pool);
            if (msg !== false) {
                msgs.push(msg);
            }
            }
        }
        }
        console.log(`${msgs.length} / ${arbCount}`);
    
        if (msgs.length === 0) return;
        const signedTx = await wallet.createAndSignTx({ msgs });
        console.log(await lcd.tx.broadcastSync(signedTx));
    }
    
    async function getPools(): Promise<Pools[]> {
        const moduleStore = await lcd.move.resource<ModuleStore>(
        moduleAddr,
        `${moduleAddr}::minitswap::ModuleStore`
        );

        const poolsTableHandle = moduleStore.data.pools.handle;
        const [poolsTable] = await lcd.move.tableEntries(poolsTableHandle);
        const pools = poolsTable.map(entity => JSON.parse(entity.value) as Pools);
        return pools;
    }
    
    async function checkCanFinalize(
        chains: Chain[],
        arbInfo: ArbInfo,
        pools: Pools
    ): Promise<Msg | false> {
        const chain = chains.find(
            chain => chain.metadata.op_bridge_id == pools.op_bridge_id
        );
        if (!chain) return false;
    
        if (!chain.metadata.executor_uri) return false;
    
        const executorClient = new APIRequester(chain.metadata.executor_uri);
        const withdrawals = await executorClient.get<Withdrawal>('tx/withdrawal', {
            address: pools.virtual_pool ? AccAddress.fromHex(pools.virtual_pool.inner) : '',
        });
    
        const withdraw = withdrawals.withdrawalTxList.find(
            w => w.l1Denom === 'uinit' && w.amount === arbInfo.ibc_op_init_sent
        );
    
        if (!withdraw || withdraw.merkleRoot === '') return false;
    
        const lastFinalizedOutput = await lcd.ophost.lastFinalizedOutput(
            Number(pools.op_bridge_id)
        );
    
        if (lastFinalizedOutput.output_index < withdraw.outputIndex) return false;
    
        const outputRes = await executorClient.get<Output>('output', {
            output_index: withdraw.outputIndex,
        });
    
        if (outputRes.outputList.length === 0) return false;
    
        const output = outputRes.outputList[0];
    
        return new MsgExecute(
            key.accAddress,
            moduleAddr,
            'minitswap',
            'finalize_arb',
            [],
            [
                bcs.u64().serialize(arbInfo.id),
                bcs.u64().serialize(output.outputIndex),
                bcs.vector(bcs.string()).serialize(withdraw.merkleProof),
                bcs.address().serialize(withdraw.sender),
                bcs.u64().serialize(withdraw.sequence),
                (() => {
                    const outputIndexBytes = intToUint8Array(withdraw.outputIndex);
                    const hashBytes = sha3_256(outputIndexBytes);
                    const base64Hash = Buffer.from(hashBytes).toString('base64');
                    return bcs.string().serialize(base64Hash);
                })(),
                bcs.string().serialize(output.stateRoot),
                bcs.string().serialize(output.merkleRoot),
                bcs.string().serialize(output.lastBlockHash),
            ].map(v => v.toBase64())
        );
    }
    
    interface ModuleStore {
        admin: string;
        arb_batch_index: string;
        arb_fee_rate: string;
        burn_cap: {
            metadata: {
                inner: string;
            };
        };
        depositor_owned_init: string;
        emergency_state: boolean;
        extend_ref: {
            self: string;
            version: string;
        };
        global_arb_batch_map: {
            handle: string;
            length: string;
        };
        ibc_timeout: string;
        max_arb_batch: string;
        max_change_rate: string;
        min_arb_interval: string;
        min_arb_profit: string;
        mint_cap: {
        metadata: {
            inner: string;
        };
        };
        pools: {
            handle: string;
            length: string;
        };
        stableswap_ann: string;
        stableswap_swap_fee_rate: string;
        swap_fee_rate: string;
        trigger_fee: string;
        unbond_period: string;
        unbond_wait_list: {
            handle: string;
            length: string;
        };
    }
    
    interface Pools {
        ibc_channel: string;
        op_bridge_id: string;
        stableswap_pool: {
            inner: string;
        } | null;
        virtual_pool: {
            inner: string;
        } | null;
    }
    
    interface Chain {
        chain_id: string;
        chain_name: string;
        pretty_name: string;
        description: string;
        website: string;
    
        metadata: {
            op_bridge_id: string;
            executor_uri: string;
            assetlist: string;
        };
        logo_URIs: {
            png: string;
            svg: string;
        };
        bech32_prefix: string;
        network_type: string;
    }
    
    interface ArbInfo {
        executed_time: string;
        ibc_op_init_metadata: string;
        ibc_op_init_sent: string;
        id: string;
        init_used: string;
        triggering_fee: string;
    }
    
    interface Withdrawal {
        count: number;
        limit: number;
        withdrawalTxList: {
            bridgeId: string;
            sequence: string;
            l1Denom: string;
            l2Denom: string;
            sender: string;
            receiver: string;
            amount: string;
            outputIndex: number;
            merkleRoot: string;
            merkleProof: string[];
        }[];
    }
    
    interface Output {
        count: number;
        limit: number;
        outputList: {
            outputIndex: number;
            outputRoot: string;
            stateRoot: string;
            merkleRoot: string;
            lastBlockHash: string;
            startBlockNumber: number;
            endBlockNumber: number;
        }[];
    }
    ```
    </Tab>
</Tabs>

## Swap via IBC hook

Generally, users will utilize minitswap in order to swap L2 INIT to L1 INIT. However, using minitswap requires two steps: 

1. L2 INIT should be sent to L1 through IBC
2. swap the transferred L2 INIT to L1 INIT. In this case, the users are burdened from having to send two transactions from both L2 and L1. 

To resolve such burden, one can use the `swap_transfer` module and IBC hook so that the steps above can be done in one transaction.

### Swap transfer

[swap-transfer.move](https://github.com/initia-labs/move-modules/blob/main/swap-transfer/sources/swap-transfer.move) is a module built for seamless interchain swap and transfer. The published address is as follows:

- initiation-2: `0x42cd8467b1c86e59bf319e5664a09b6b5840bb3fac64f5ce690b5041c530565a`

### Minitswap to

`minit_swap_to` is a function for using minitswap through IBC hook. The Move function interface is as follows:

```move
public entry fun minit_swap_to(
    account: &signer,
    offer_asset_metadata: Object<Metadata>,
    return_asset_metadata: Object<Metadata>,
    amount: u64,
    min_return_amount: Option<u64>,
    to: address,
)
```

- `offer_asset_metadata`: Metadata for the coin to provide 
- `return_asset_metadata`: Metadata for the coin to be returned.
- `amount`: Amount of coin to provide.
- `min_return_amount`: Minimum value for the swap. If the return amount is smaller than min_return_amount, the tx will fail.
- `to`: Address to receive the returned coin.

**Example Usage:**

```ts
import {
  bcs,
  Coin,
  Height,
  LCDClient,
  MnemonicKey,
  MsgExecute,
  MsgTransfer,
  Wallet,
} from '@initia/initia.js';

async function main() {
  const lcd = new LCDClient('[rest-url]', {
    gasPrices: '0.15uinit',
    gasAdjustment: '1.5',
  });

  const key = new MnemonicKey({
    mnemonic: 'beauty sniff protect ...',
  });
  const wallet = new Wallet(lcd, key);

  const moduleAddresss = '0x...';
  const offerAmount = 1000;
  const hookMsg = {
    move: {
      message: {
        module_address: moduleAddresss,
        module_name: 'swap_trasnfer',
        function_name: 'minit_swap_to',
        type_args: [],
        args: [
          bcs.object().serialize('0x...').toBase64(), // metadata to offer
          bcs.object().serialize('0x...').toBase64(), // metadata to return
          bcs.u64().serialize(100).toBase64(), // offer amount
          bcs.option(bcs.u64()).serialize(offerAmount).toBase64(), // min return amount
          bcs.address().serialize('init1...').toBase64(), // to
        ],
      },
    },
  };

  const msgs = [
    new MsgTransfer(
      'transfer',
      'channel-..',
      new Coin('l2/...', offerAmount),
      key.accAddress,
      `${moduleAddresss}::${hookMsg.move.message.module_name}::${hookMsg.move.message.function_name}`,
      new Height(0, 0),
      ((new Date().valueOf() + 1000 * 60) * 1000000).toString(), // timeout
      JSON.stringify(hookMsg)
    ),
  ];

  // sign tx
  const signedTx = await wallet.createAndSignTx({ msgs });
  // send(broadcast) tx
  lcd.tx.broadcastSync(signedTx).then(res => console.log(res));
  // {
  //   height: 0,
  //   txhash: '0F2B255EE75FBA407267BB57A6FF3E3349522DA6DBB31C0356DB588CC3933F37',
  //   raw_log: '[]'
  // }
}

main();
```