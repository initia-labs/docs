---
title: Integrating Initia Minitswap
---

## Provide

To provide INIT liquidity to Minitswap, you would need to use the `provide` function. 

By adding liquidity, you will help facilitate swaps between L1 and L2 INIT tokens. In return, you'll earn swap fees and arbitrage fees generated from the transactions that occur on Minitswap.

**Move Function Interface:**

```ts
public entry fun provide(
  account: &signer,
  amount: u64,
  min_return_amount: Option<u64>,
)
```

- `amount`: The amount of L1 INIT to provide.
- `min_return_amount`: The minimum acceptable amount of LP tokens to be returned from the provide action. If the actual amount returned is less than this, the transaction will be reverted.

**Example Usage:**

<Tabs>
    <Tab title="CLI">
    ```bash
    initiad tx move execute 0x1 minitswap provide \
        --args '["u64:100", "option<u64>:null"]' \
        --from [key-name] \
        --gas auto --gas-adjustment 1.5 --gas-prices 0.015uinit \
        --node [rpc-url]:[rpc-port] --chain-id [chain-id]
    ```
    </Tab>
    <Tab title="InitiaJS">
    ```ts
    import {
        bcs,
        RESTClient,
        MnemonicKey,
        MsgExecute,
        Wallet,
    } from '@initia/initia.js';

    async function main() {
        const rest = new RESTClient('[rest-url]', {
            gasPrices: '0.015uinit',
            gasAdjustment: '1.5',
        });

        const key = new MnemonicKey({
            mnemonic: 'beauty sniff protect ...',
        });
        const wallet = new Wallet(rest, key);

        const msgs = [
            new MsgExecute(
                key.accAddress,
                '0x1',
                'minitswap',
                'provide',
                [],
                [
                    bcs.u64().serialize(100).toBase64(), // amount to provide
                    bcs.option(bcs.u64()).serialize(null).toBase64(), // min return amount
                ]
            ),
        ];

        // sign tx
        const signedTx = await wallet.createAndSignTx({ msgs });
        // send(broadcast) tx
        rest.tx.broadcastSync(signedTx).then(res => console.log(res));
        // {
        //   height: 0,
        //   txhash: '0F2B255EE75FBA407267BB57A6FF3E3349522DA6DBB31C0356DB588CC3933F37',
        //   raw_log: '[]'
        // }
    }

    main();
    ```
    </Tab>
</Tabs>

## Unbond

Before withdrawing your liquidity, you must first unbond your LP tokens. This process takes 7 days to complete.

Minitswap depositors take risk of L2 fraud. By having 7-day unbonding period, all depositors will share the responsibility of L2 fraud equally.

**Move Function Interface:**

```move
public entry fun unbond(
  account: &signer,
  amount: u64
)
```

- `amount`: The amount of LP tokens to unbond.

<Tabs>
    <Tab title="CLI">
    ```bash
    initiad tx move execute 0x1 minitswap unbond \
        --args '["u64:100"]' \
        --from [key-name] \
        --gas auto --gas-adjustment 1.5 --gas-prices 0.015uinit \
        --node [rpc-url]:[rpc-port] --chain-id [chain-id]
    ```
    </Tab>
    <Tab title="InitiaJS">
    ```ts
    import {
        bcs,
        RESTClient,
        MnemonicKey,
        MsgExecute,
        Wallet,
    } from '@initia/initia.js';

    async function main() {
        const rest = new RESTClient('[rest-url]', {
            gasPrices: '0.015uinit',
            gasAdjustment: '1.5',
        });

        const key = new MnemonicKey({
            mnemonic: 'beauty sniff protect ...',
        });
        const wallet = new Wallet(rest, key);

        const msgs = [
            new MsgExecute(
                key.accAddress,
                '0x1',
                'minitswap',
                'unbond',
                [],
                [
                    bcs.u64().serialize(100).toBase64(), // amount to unbond
                ]
            ),
        ];

        // sign tx
        const signedTx = await wallet.createAndSignTx({ msgs });
        // send(broadcast) tx
        rest.tx.broadcastSync(signedTx).then(res => console.log(res));
        // {
        //   height: 0,
        //   txhash: 'E8498469AA40E0F22499F412A009F86CE037B02C78C111078C9C4C990C1E0D18',
        //   raw_log: '[]'
        // }
    }

    main();
    ```
    </Tab>
</Tabs>

## Withdraw Unbond

After the 7-day unbonding period, you can withdraw your LP tokens using the `withdraw_unbond` function.

This allows you to freely exit your position whenever you'd like and reclaim your provided liquidity plus any fees youâ€™ve earned along the way.

**Move Function Interface:**

```move
public entry fun withdraw_unbond(
  account: &signer,
  release_time: u64
)
```

- `release_time`: The time when the LP tokens will be released.

To retrieve the release time, you can use the `get_unbond_list` view function.

```move
public fun get_unbond_list(
  account: address,
  start_after: Option<u64>,
  limit: u64
)
```

**Example Usage:**

<Tabs>
    <Tab title="CLI">
    ```bash
    initiad tx move execute 0x1 minitswap withdraw_unbond \
        --args '["u64:100"]' \
        --from [key-name] \
        --gas auto --gas-adjustment 1.5 --gas-prices 0.015uinit \
        --node [rpc-url]:[rpc-port] --chain-id [chain-id]
    ```
    </Tab>
    <Tab title="InitiaJS">
    ```ts
    import {
        bcs,
        RESTClient,
        MnemonicKey,
        MsgExecute,
        Wallet,
    } from '@initia/initia.js';

    async function main() {
        const rest = new RESTClient('[rest-url]', {
            gasPrices: '0.015uinit',
            gasAdjustment: '1.5',
        });

        const key = new MnemonicKey({
            mnemonic: 'beauty sniff protect ...',
        });
        const wallet = new Wallet(rest, key);

        const msgs = [
            new MsgExecute(
                key.accAddress,
                '0x1',
                'minitswap',
                'withdraw_unbond',
                [],
                [
                    bcs.u64().serialize(100).toBase64(), // release time
                ]
            ),
        ];

        // sign tx
        const signedTx = await wallet.createAndSignTx({ msgs });
        // send(broadcast) tx
        rest.tx.broadcastSync(signedTx).then(res => console.log(res));
        // {
        //   height: 0,
        //   txhash: '0F2B255EE75FBA407267BB57A6FF3E3349522DA6DBB31C0356DB588CC3933F37',
        //   raw_log: '[]'
        // }
    }

    main();
    ```
    </Tab>
</Tabs>

## Swap

The `swap` function allows you to exchange L2 INIT for L1 INIT or vice versa.

**Move Function Interface:**

```move
public entry fun swap(
    account: &signer,
    offer_asset_metadata: Object<Metadata>,
    return_asset_metadata: Object<Metadata>,
    amount: u64,
    min_return_amount: Option<u64>
)
```

- `offer_asset_metadata`: Metadata for the provided coin.
- `return_asset_metadata`: Metadata for the coin to be returned.
- `amount`: Coin amount provided.
- `min_return_amount`: The minimum amount of coin to be returned. If the actual amount returned is less than this, the transaction will be reverted.

For more information on metadata, please refer to [obtaining metadata](/developers/developer-guides/vm-specific-tutorials/movevm/creating-move-coin#obtaining-metadata).

**Example Usage:**

<Tabs>
    <Tab title="CLI">
    ```bash
    initiad tx move execute 0x1 minitswap swap \
        --args '["object:0x12..", "object: 0x12..", "u64:100", "option<u64>:100"]' \
        --from [key-name] \
        --gas auto --gas-adjustment 1.5 --gas-prices 0.015uinit \
        --node [rpc-url]:[rpc-port] --chain-id [chain-id]
    ```
    </Tab>
    <Tab title="InitiaJS">
    ```ts
    import {
        bcs,
        RESTClient,
        MnemonicKey,
        MsgExecute,
        Wallet,
    } from '@initia/initia.js';

    async function main() {
        const rest = new RESTClient('[rest-url]', {
            gasPrices: '0.015uinit',
            gasAdjustment: '1.5',
        });

        const key = new MnemonicKey({
            mnemonic: 'beauty sniff protect ...',
        });
        const wallet = new Wallet(rest, key);

        const msgs = [
            new MsgExecute(
            key.accAddress,
            '0x1',
            'minitswap',
            'swap',
            [],
            [
                bcs.object().serialize('0x...').toBase64(), // metadata to offer
                bcs.object().serialize('0x...').toBase64(), // metadata to return
                bcs.u64().serialize(100).toBase64(), // offer amount
                bcs.option(bcs.u64()).serialize(100).toBase64(), // min return amount
            ]
            ),
        ];

        // sign tx
        const signedTx = await wallet.createAndSignTx({ msgs });
        // send(broadcast) tx
        rest.tx.broadcastSync(signedTx).then(res => console.log(res));
        // {
        //   height: 0,
        //   txhash: '0F2B255EE75FBA407267BB57A6FF3E3349522DA6DBB31C0356DB588CC3933F37',
        //   raw_log: '[]'
        // }
    }

    main();
    ```
    </Tab>
</Tabs>

`swap_simulation` is a view function to estimate the return value of said swap. 

```move
#[view]
public fun swap_simulation(
    offer_metadata: Object<Metadata>,
    return_metadata: Object<Metadata>,
    offer_amount: u64,
): (u64, u64) // (return amount, fee amount)
```
- `offer_asset_metadata`: Metadata of the provided coin.
- `return_asset_metadata`: Metadata of the coin that will be returned.
- `amount`: Coin amount provided.

**Example Usage:**

<Tabs>
    <Tab title="curl">
    ```bash
    curl -X POST "[LCD_URI]/initia/move/v1/accounts/0x1/modules/minitswap/view_functions/swap_simulation" \
        -H "accept: application/json" \
        -H "Content-Type: application/json" \
        -d "{ \"args\": [ \"[BCS_ENCODED_OBJECT, BCS_ENCODED_OBJECT, BCS_ENCODED_OFFER_AMOUNT]\" ]}"
  
    #{
    #  "data": "[\"100\",\"100\"]",
    #  "events": [],
    #  "gas_used": "5699"
    #}        
    ```
    </Tab>
    <Tab title="CLI">
    ```bash
    initiad query move view 0x1 minitswap swap_simulation \
        --args '["object:0x...", "object:0x...", "u64:123"]' \
        --node [rpc-url]:[rpc-port]
        
    # data: '["123", "123"]'
    # events: []
    # gas_used: "5699"
    ```
    </Tab>
    <Tab title="InitiaJS">
    ```ts
    import { RESTClient, bcs } from '@initia/initia.js';

    const restUrl = 'https://....';
    const rest = new RESTClient(restUrl);

    rest.move
        .view(
            '0x1',
            'minitswap',
            'swap_simulation',
            [],
            [
                bcs.object().serialize('0x...').toBase64(),
                bcs.object().serialize('0x...').toBase64(),
                bcs.u64().serialize(100).toBase64(),
            ]
        )
        .then(console.log);

    // { data: '["100","0"]', events: [], gas_used: '21371' }
    ```
    </Tab>
</Tabs>


## Arbitrage

Arbitrage on Minitswap helps balance L1 INIT and L2 INIT prices. 

Use the `finalize_arb` function to complete arbitrage transactions after the L2 INIT challenge period. 

Arbitrage profits are shared between the `function caller` and the `LP provider`. 

Required arguments for `finalize_arb` can be obtained from the `OPinit Executor` and Minitswap view function

**Move Function Interface:**

```move
public entry fun finalize_arb(
    account: &signer,
    arb_index: u64,
    output_index: u64,
    withdrawal_proofs: vector<String>,
    sender: address,
    sequence: u64,
    version: String,
    state_root: String,
    storage_root: String,
    latest_block_hash: String
)
```

- `arb_index`: Unique identifier for the arbitrage operation. It is used to track the specific arbitrage transaction being finalized.
- `output_index`: Index of the output related to the arbitrage.
- `withdrawal_proofs`: A set of proofs required to validate the withdrawal action. These proofs ensure the legitimacy of the funds being withdrawn.
- `sender`: Address of the account that initiated the withdrawal process.
- `sequence`: Sequence number to ensure the correct order of transactions.
- `version`: Version identifier for the output root being used. Currently, the version is set to `0`.
- `state_root`: The state root of the L2 blockchain at the time of the withdrawal.
- `storage_root`: Root hash representing the storage related to the withdrawal.
- `latest_block_hash`: The hash of the latest L2 block to ensure consistency.

To obtain the required arguments, you should 

**Example Usage:**

<Tabs>
    <Tab title="CLI">
    ```bash
    initiad tx move execute 0x1 minitswap finalize_arb \
        --args "" \
        --from [key-name] \
        --gas auto --gas-adjustment 1.5 --gas-prices 0.015uinit \
        --node [rpc-url]:[rpc-port] --chain-id [chain-id]
    ```
    </Tab>
    <Tab title="InitiaJS">
    ```ts
    import {
        APIRequester,
        AccAddress,
        RESTClient,
        MnemonicKey,
        Msg,
        MsgExecute,
        Wallet,
        bcs,
    } from '@initia/initia.js';
    import { sha3_256 } from "@noble/hashes/sha3";
    import { bytesToHex, concatBytes, toBytes, hexToBytes } from "@noble/hashes/utils";
    import { toHex } from "@cosmjs/encoding"
    import { sha256 } from "@noble/hashes/sha256";
    
    function denomToHash(channelId: string, denom: string) {
        const fullTrace = `transfer/${channelId}/${denom}`
        const shaSum = sha256(Buffer.from(fullTrace))
        return bytesToHex(shaSum)
    }

    function ibcDenom(channelId: string, denom: string) {
        return 'ibc/' + denomToHash(channelId, denom).toUpperCase()
    }

    function be(num: bigint): number[] {
        return num ? be(num >> 8n).concat([Number(num % 256n)]) : []
    }
    
    function u64BE(num: bigint) {
        const b = be(num)
        return Buffer.from(
        Array(8 - b.length)
            .fill(0)
            .concat(b)
        )
    }
    
    function intToUint8Array(value: number): Uint8Array {
        let hex = value.toString(16);
        if (hex.length % 2 !== 0) {
        hex = '0' + hex;
        }
        return hexToBytes(hex);
    }

    function opdenom(id: bigint, l1Denom: string) {
        const sum = sha3_256
        .create()
        .update(Buffer.from([...u64BE(id), ...Buffer.from(l1Denom)]))
        .digest()
    
        return `l2/${Buffer.from(sum).toString('hex')}`
    }
    
    function coinMetadata(creator: string, symbol: string) {
        const OBJECT_FROM_SEED_ADDRESS_SCHEME = 0xfe
        const addrBytes = bcs.address().serialize(creator).toBytes()
        const seed = toBytes(symbol)
        const bytes = new Uint8Array([...concatBytes(addrBytes, seed), OBJECT_FROM_SEED_ADDRESS_SCHEME])
        const sum = sha3_256.create().update(bytes).digest()
        return toHex(sum)
    }

    const registryClient = new APIRequester('https://registry.testnet.initia.xyz/');
    const rest = new RESTClient(`https://rest.initiation-2.initia.xyz`, {
        chainId: 'initiation-2',
        gasPrices: '0.015uinit',
        gasAdjustment: '2.0',
    });
    const moduleAddr = '0x1';
    
    const key = new MnemonicKey({
        mnemonic: '', // Put your mnemonic here
    });
    
    const wallet = new Wallet(rest, key);
    
    async function main() {
        listUp();
    }
    main();
    
    async function listUp() {
        const pools = await getPools();
        console.log(pools.map(p => p.virtual_pool ? p.virtual_pool.inner : null));
        const chains = await registryClient.get<Chain[]>('chains.json');
        const msgs: Msg[] = [];
        let arbCount = 0;
        for (const pool of pools) {
            if (pool.virtual_pool) {
                const channel = pool.ibc_channel;
                const bridgeId = pool.op_bridge_id;
                const ibcOpInitDenom = ibcDenom(
                    channel,
                    opdenom(BigInt(bridgeId), 'uinit')
                );
                const ibcOpInitMetadata = '0x' + coinMetadata('0x1', ibcOpInitDenom);
                const infos = await rest.move.viewFunction<ArbInfo[]>(
                    moduleAddr,
                    'minitswap',
                    'get_arb_infos',
                    [],
                    [
                        bcs.object().serialize(ibcOpInitMetadata).toBase64(),
                        bcs.option(bcs.u64()).serialize(null).toBase64(),
                        bcs.u64().serialize(100).toBase64(),
                    ]
                );
        
                for (const info of infos) {
                    arbCount++;
                    const msg = await checkCanFinalize(chains, info, pool);
                    if (msg !== false) {
                        msgs.push(msg);
                    }
                }
            }
        }
        console.log(`${msgs.length} / ${arbCount}`);
    
        if (msgs.length === 0) return;
        const signedTx = await wallet.createAndSignTx({ msgs });
        console.log(await rest.tx.broadcastSync(signedTx));
    }
    
    async function getPools(): Promise<Pools[]> {
        const moduleStore = await rest.move.resource<ModuleStore>(
            moduleAddr,
            `${moduleAddr}::minitswap::ModuleStore`
        );

        const poolsTableHandle = moduleStore.data.pools.handle;
        const [poolsTable] = await rest.move.tableEntries(poolsTableHandle);
        const pools = poolsTable.map(entity => JSON.parse(entity.value) as Pools);
        return pools;
    }
    
    async function checkCanFinalize(
        chains: Chain[],
        arbInfo: ArbInfo,
        pools: Pools
    ): Promise<Msg | false> {
        const chain = chains.find(
            chain => chain.metadata.op_bridge_id == pools.op_bridge_id
        );
        if (!chain) return false;
    
        if (!chain.metadata.executor_uri) return false;
    
        const executorClient = new APIRequester(chain.metadata.executor_uri);
        const withdrawals = await executorClient.get<Withdrawal>('tx/withdrawal', {
            address: pools.virtual_pool ? AccAddress.fromHex(pools.virtual_pool.inner) : '',
        });
    
        const withdraw = withdrawals.withdrawalTxList.find(
            w => w.l1Denom === 'uinit' && w.amount === arbInfo.ibc_op_init_sent
        );
    
        if (!withdraw || withdraw.merkleRoot === '') return false;
    
        const lastFinalizedOutput = await rest.ophost.lastFinalizedOutput(
            Number(pools.op_bridge_id)
        );
    
        if (lastFinalizedOutput.output_index < withdraw.outputIndex) return false;
    
        const outputRes = await executorClient.get<Output>('output', {
            output_index: withdraw.outputIndex,
        });
    
        if (outputRes.outputList.length === 0) return false;
    
        const output = outputRes.outputList[0];
    
        return new MsgExecute(
            key.accAddress,
            moduleAddr,
            'minitswap',
            'finalize_arb',
            [],
            [
                bcs.u64().serialize(arbInfo.id),
                bcs.u64().serialize(output.outputIndex),
                bcs.vector(bcs.string()).serialize(withdraw.merkleProof),
                bcs.address().serialize(withdraw.sender),
                bcs.u64().serialize(withdraw.sequence),
                (() => {
                    const outputIndexBytes = intToUint8Array(withdraw.outputIndex);
                    const hashBytes = sha3_256(outputIndexBytes);
                    const base64Hash = Buffer.from(hashBytes).toString('base64');
                    return bcs.string().serialize(base64Hash);
                })(),
                bcs.string().serialize(output.stateRoot),
                bcs.string().serialize(output.merkleRoot),
                bcs.string().serialize(output.lastBlockHash),
            ].map(v => v.toBase64())
        );
    }
    
    interface ModuleStore {
        admin: string;
        arb_batch_index: string;
        arb_fee_rate: string;
        burn_cap: {
            metadata: {
                inner: string;
            };
        };
        depositor_owned_init: string;
        emergency_state: boolean;
        extend_ref: {
            self: string;
            version: string;
        };
        global_arb_batch_map: {
            handle: string;
            length: string;
        };
        ibc_timeout: string;
        max_arb_batch: string;
        max_change_rate: string;
        min_arb_interval: string;
        min_arb_profit: string;
        mint_cap: {
        metadata: {
            inner: string;
        };
        };
        pools: {
            handle: string;
            length: string;
        };
        stableswap_ann: string;
        stableswap_swap_fee_rate: string;
        swap_fee_rate: string;
        trigger_fee: string;
        unbond_period: string;
        unbond_wait_list: {
            handle: string;
            length: string;
        };
    }
    
    interface Pools {
        ibc_channel: string;
        op_bridge_id: string;
        stableswap_pool: {
            inner: string;
        } | null;
        virtual_pool: {
            inner: string;
        } | null;
    }
    
    interface Chain {
        chain_id: string;
        chain_name: string;
        pretty_name: string;
        description: string;
        website: string;
    
        metadata: {
            op_bridge_id: string;
            executor_uri: string;
            assetlist: string;
        };
        logo_URIs: {
            png: string;
            svg: string;
        };
        bech32_prefix: string;
        network_type: string;
    }
    
    interface ArbInfo {
        executed_time: string;
        ibc_op_init_metadata: string;
        ibc_op_init_sent: string;
        id: string;
        init_used: string;
        triggering_fee: string;
    }
    
    interface Withdrawal {
        count: number;
        limit: number;
        withdrawalTxList: {
            bridgeId: string;
            sequence: string;
            l1Denom: string;
            l2Denom: string;
            sender: string;
            receiver: string;
            amount: string;
            outputIndex: number;
            merkleRoot: string;
            merkleProof: string[];
        }[];
    }
    
    interface Output {
        count: number;
        limit: number;
        outputList: {
            outputIndex: number;
            outputRoot: string;
            stateRoot: string;
            merkleRoot: string;
            lastBlockHash: string;
            startBlockNumber: number;
            endBlockNumber: number;
        }[];
    }
    ```
    </Tab>
</Tabs>